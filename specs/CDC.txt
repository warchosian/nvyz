
### **Nom du projet : nvyz**  

**CLI Command** : `nvyz` (alias `nvyz` pour les utilisateurs avancés)  
**Tagline** : *"Where code flaws become golden insights."*  

---

#### **1. Nom du projet**  
- **nvyz Code Forge** évoque :  
  - **Résilience** : Comme le nvyz, l'outil transforme les défauts en forces.  
  - **Précision** : "Forge" rappelle la méticulosité de l'analyse sémantique.  
  - **Originalité** : Aucun outil majeur ne porte ce nom (vérifié via [npm](https://www.npmjs.com/), [PyPI](https://pypi.org/), et GitHub).  

#### **2. Dépendances clés**  
| Dépendance | Rôle critique | Alternative rejetée |  
|------------|---------------|---------------------|  
| `tree-sitter` + grammars | Parsing sémantique rapide et précis | `libclang` (trop lourd pour Java/JS) |  
| `pydantic[yaml]` | Validation stricte des configs utilisateur | `marshmallow` (moins performant avec YAML) |  
| `cryptography` | Chiffrement AES-256 des rapports avant envoi | `pycryptodome` (dépendances système complexes) |  
| `joblib` | Parallélisation sans overhead mémoire | `multiprocessing` natif (gestion manuelle des processus) |  
| `sarif-om` | Génération de rapports standardisés | `json` brut (non compatible avec GitHub/Azure DevOps) |  

#### **3. Sécurité renforcée**  
- **`python-dotenv`** : Interdit le stockage des tokens MCP dans les fichiers de config.  
- **`bandit`** en dépendance de dev : Audit statique du code de *nvyz* lui-même.  
- **Pré-commit hooks** : Blocage des commits avec tokens hardcodés (via `detect-secrets`).  

#### **4. Expérience utilisateur**  
- **Alias `nvyz`** : Pour les experts pressés.  
- **`rich`** : Progress bars en temps réel, tables colorées pour les rapports, et emojis contextuels (?/??/??).  
- **PyInstaller** : Binaires natifs sans dépendances Python (fournis via un registre interne).  

---

### **Exemple d'utilisation post-installation**  
```bash
# Installation depuis le registre interne
pip install nvyz-core --index-url https://pypi.entreprise.com/simple

# Analyse rapide avec affichage interactif
nvyz semantic-scan ./src --lang=python --interactive

# Résultat stylisé via Rich
+-------------------------------------------------------+
¦ Fichier    ¦ Problème                     ¦ Sévérité  ¦
+------------+------------------------------+-----------¦
¦ auth.py:42 ¦ SQL injection via user input ¦ ?? CRITICAL ¦
¦ utils.py:7 ¦ Variable non utilisée        ¦ ?? WARNING ¦
+-------------------------------------------------------+
?? Rapport envoyé à MCP • ID: nvyz-2025-9f8e2a
```

---

### **Roadmap post-v1**  
- **Plugins marketplace** : `nvyz plugin install --official security-rules-java`  
- **Analyse temps réel** : Intégration avec les IDE (VS Code, PyCharm) via Language Server Protocol (LSP).  
- **Carbon footprint** : Calcul de l'impact environnemental des mauvais patterns (ex: boucles infinies gourmandes en CPU).  

Ce projet allie **poésie technique** (nvyz) et **rigueur industrielle** (MCP), en positionnant l'équipe comme pionnière de l'analyse sémantique *humaine* et opérationnelle. ??
---

### **Intégration stratégique de CodeQL dans nvyz Code Forge**  
*(Réponse structurée pour concilier innovation et pragmatisme)*  

---

#### **1. Positionnement de CodeQL**  
CodeQL est un **moteur d’analyse sémantique de pointe** (spécialisé en sécurité) développé par GitHub. Plutôt que de le concurrencer, **nvyz l’intègre de manière complémentaire** :  
- **Cas d’usage prioritaire** :  
  - Détection de vulnérabilités complexes (injections SQL, XSS, désérialisation non sécurisée).  
  - Analyse *cross-language* (ex: flux de données entre Python backend et JavaScript frontend).  
- **Limites de CodeQL** :  
  - Moins adapté aux métriques métier (complexité cognitive, couplage).  
  - Licence restrictive pour les entreprises (gratuit pour l’open source, payant pour GitHub Advanced Security en entreprise).  

? **Stratégie nvyz** : CodeQL devient un *plugin optionnel* pour les équipes disposant déjà d’une licence GitHub Advanced Security.  

---

#### **2. Architecture technique d’intégration**  
##### **2.1 Plugin CodeQL**  
```python  
# src/app/plugins/codeql_plugin.py  
from ..core.plugin import AnalyzerPlugin  

class CodeQLPlugin(AnalyzerPlugin):  
    def __init__(self, license_token: str):  
        self.license_token = license_token  # Token GitHub Advanced Security  

    def analyze(self, path: str, ruleset: str = "security") -> AnalysisResult:  
        """  
        Appelle le CLI CodeQL en subprocess et convertit les résultats au format nvyz  
        """  
        cmd = [  
            "codeql", "database", "create", "--language=python", "--source-root", path, "db"  
        ]  
        subprocess.run(cmd, check=True)  
        
        results = subprocess.check_output([  
            "codeql", "database", "analyze", "db",  
            f"--queries={ruleset}",  
            "--format=sarif",  
            "--output=results.sarif",  
            f"--github-token={self.license_token}"  
        ])  
        return self._convert_sarif_to_nvyz(results)  
```  

##### **2.2 Hiérarchie des analyseurs**  
```mermaid  
graph LR  
    A[Commande CLI nvyz security-taint] --> B{Plugin CodeQL disponible ?}  
    B -->|Oui| C[Utiliser CodeQL pour les règles complexes]  
    B -->|Non| D[Utiliser l'analyseur Tree-sitter natif]  
    C --> E[Fusionner les résultats avec les métriques nvyz]  
    D --> E  
    E --> F[Exporter vers MCP]  
```  

---

#### **3. Dépendances mises à jour dans `pyproject.toml`**  
```toml  
[tool.poetry.dependencies]  
# ... autres dépendances existantes ...  

# Dépendances optionnelles pour CodeQL (plugin)  
codeql = { version = "^2.15", optional = true }  # Version CLI compatible  

[tool.poetry.extras]  
codeql = ["codeql"]  # Activation via poetry install -E codeql  
```  

**Notes** :  
- CodeQL n’est **pas une dépendance Python classique**, mais un binaire externe. Le plugin vérifie sa présence via `shutil.which("codeql")`.  
- L’installation est documentée comme *optionnelle* :  
  ```bash  
  # Pour les utilisateurs avec licence GitHub Advanced Security  
  sudo apt-get install codeql-cli  
  poetry install -E codeql  
  ```  

---

#### **4. Workflow utilisateur concret**  
```bash  
# 1. Activer le plugin CodeQL (nécessite une licence GitHub)  
nvyz plugin enable codeql --github-token=ghs_XXXX  

# 2. Lancer une analyse hybride (CodeQL + analyseurs natifs)  
nvyz security-taint ./src --lang=python --use-codeql  

# 3. Résultats fusionnés dans MCP  
? 12 vulnérabilités CodeQL détectées (CVE-2024-XXXX)  
? 3 problèmes de couplage identifiés par nvyz  
?? Rapport unifié envoyé à MCP • ID: nvyz-2025-7a3f9b  
```  

---

#### **5. Gestion des licences et coûts**  
| Scénario | Solution nvyz |  
|----------|-------------------|  
| **Équipe open source** | Utilise les analyseurs natifs (Tree-sitter) + règles gratuites de CodeQL (sans Advanced Security). |  
| **Entreprise avec GitHub Advanced Security** | Active le plugin CodeQL pour les requêtes premium (ex: *query suites* pour Log4j-like). |  
| **Environnement air-gapped** | Désactive CodeQL et utilise uniquement les règles embarquées dans nvyz. |  

? **Transparence dans la CLI** :  
```bash  
$ nvyz plugin list  
[?] tree-sitter-python  
[?] semantic-metrics  
[?] codeql (non installé - nécessite codeql-cli et licence GitHub)  
```  

---

#### **6. Roadmap : Phase 2 (Post-V1)**  
1. **Intégration native CodeQL** :  
   - Support des *custom queries* via `--codeql-queries=./custom-queries`.  
   - Cache des bases de données CodeQL pour accélérer les ré-analyses.  
2. **Benchmarking** :  
   - Comparaison des taux de faux positifs entre CodeQL et les analyseurs nvyz.  
3. **Fallback intelligent** :  
   - Si CodeQL échoue (ex: timeout), bascule automatique sur l’analyseur Tree-sitter avec alerte utilisateur.  

---

#### **7. Pourquoi cette approche ?**  
- **Évolutivité** : Les équipes adoptent CodeQL progressivement sans bloquer le déploiement de nvyz.  
- **Interopérabilité** : nvyz devient un *unificateur* d’outils (CodeQL, Semgrep, analyzers maison) plutôt qu’un monolithe.  
- **Conformité** : Respect des licences logicielles via une activation explicite (pas de dépendance implicite à CodeQL).  

> ?? **Message clé** :  
> *« nvyz ne remplace pas CodeQL — il le valorise en le plaçant dans un workflow DevOps complet, avec reporting unifié et correction automatisée. »*  

---

### **Exemple de configuration .mcpconfig.yaml avec CodeQL**  
```yaml  
plugins:  
  codeql:  
    enabled: true  
    license_token_env: "GITHUB_ADVANCED_SECURITY_TOKEN"  
    query_suites:  
      - "security-and-quality"  
      - "./custom-rules/java-deserialization.qls"  

analyzers:  
  python:  
    rules:  
      - id: "custom-unused-vars"  # Règle nvyz native  
        severity: warning  
```  

Cette architecture fait de **nvyz une plateforme ouverte**, capable de s’adapter aux outils existants (CodeQL) tout en innovant sur l’expérience utilisateur et l’intégration MCP. ??

---

### **Intégration de règles SonarQube dans nvyz Code Forge**  
*(Une approche pragmatique pour unifier les écosystèmes d’analyse)*  

---

#### **1. Vision stratégique**  
SonarQube reste la référence industrielle pour les **code smells** et les métriques de qualité (dette technique, duplications). Plutôt que de réinventer ces règles, **nvyz les intègre via un plugin hybride** :  
- **Cas d’usage** :  
  - Import des règles métier existantes (ex: règles "Security Hotspots" de SonarQube).  
  - Compatibilité avec les projets déjà monitorés par SonarQube.  
- **Différenciation** :  
  - nvyz ajoute une **couche sémantique** (flux de données, graphes d’appels) absente dans SonarQube.  
  - Fusion des résultats SonarQube + analyseurs natifs nvyz dans un **rapport unifié** pour MCP.  

? **Positionnement** : *nvyz n’est pas un remplacement de SonarQube, mais son "cerveau sémantique"*.  

---

#### **2. Architecture technique**  
##### **2.1 Plugin SonarQube**  
```python  
# src/nvyz/plugins/sonarqube_plugin.py  
import json  
import subprocess  
from ..core.plugin import AnalyzerPlugin  
from ..integrations.sarif_converter import SarifConverter  

class SonarQubePlugin(AnalyzerPlugin):  
    """  
    Mode hybride :  
    - Online : Appel API SonarQube pour récupérer les issues existantes  
    - Offline : Exécution de SonarScanner CLI en mode local (sans serveur)  
    """  

    def __init__(self, mode="offline", server_url=None, token=None):  
        self.mode = mode  
        self.server_url = server_url  
        self.token = token  

    def analyze(self, path: str, project_key: str = None) -> AnalysisResult:  
        if self.mode == "online" and project_key:  
            return self._fetch_from_server(project_key)  
        else:  
            return self._run_local_scan(path)  

    def _run_local_scan(self, path: str) -> AnalysisResult:  
        """  
        Exécute SonarScanner en mode autonome (règles embarquées)  
        Génère un rapport SARIF compatible  
        """  
        subprocess.run([  
            "sonar-scanner",  
            f"-Dproject.settings={path}/sonar-project.properties",  
            "-Dsonar.scm.disabled=true",  
            "-Dsonar.report.export.path=sonar-report.json"  # Export local  
        ], check=True)  
        with open("sonar-report.json") as f:  
            raw_results = json.load(f)  
        return SarifConverter.convert_sonar_to_nvyz(raw_results)  
```  

##### **2.2 Workflow fusionné**  
```mermaid  
graph LR  
    A[Code source] --> B(nvyz Core)  
    A --> C[SonarScanner CLI]  
    C --> D{Mode ?}  
    D -->|Online| E[SonarQube Server API]  
    D -->|Offline| F[Fichier sonar-report.json]  
    E & F --> G[Conversion SARIF]  
    B --> H[Fusion des résultats]  
    G --> H  
    H --> I[Rapport unifié pour MCP]  
```  

---

#### **3. Dépendances mises à jour dans `pyproject.toml`**  
```toml  
[tool.poetry.dependencies]  
# ... autres dépendances ...  

# Plugin SonarQube (optionnel)  
requests = { version = "^2.31", optional = true }  
xmltodict = { version = "^0.13", optional = true }  # Pour parser les rapports historiques XML  

[tool.poetry.extras]  
sonarqube = ["requests", "xmltodict"]  
codeql = ["codeql"]  
```  

**Prérequis système** :  
- **SonarScanner CLI** doit être installé séparément (non packagé dans nvyz par licence).  
- Configuration minimale pour le mode offline :  
  ```properties  
  # sonar-project.properties  
  sonar.projectKey=my-project  
  sonar.sources=src  
  sonar.language=py  
  sonar.qualitygate.wait=true  
  ```  

---

#### **4. Commandes CLI dédiées**  
| Commande | Description | Exemple |  
|----------|-------------|---------|  
| `nvyz sonar-import` | Importe les issues depuis un serveur SonarQube | `nvyz sonar-import --project-key=backend-api --server-url=https://sonar.entreprise.com` |  
| `nvyz sonar-scan` | Exécute une analyse locale avec SonarScanner | `nvyz sonar-scan ./src --ruleset=security-hotspots` |  
| `nvyz fuse-results` | Fusionne résultats SonarQube + analyseurs nvyz | `nvyz fuse-results --sonar-report=sonar.json --nvyz-report=semantic.json` |  

**Exemple de workflow** :  
```bash  
# 1. Analyse locale avec SonarScanner (sans serveur)  
nvyz sonar-scan ./src --output=sonar.json  

# 2. Analyse sémantique nvyz native  
nvyz semantic-scan ./src --output=nvyz.json  

# 3. Fusion et envoi à MCP  
nvyz fuse-results sonar.json nvyz.json --push-to-mcp  
```  

---

#### **5. Configuration dans `.mcpconfig.yaml`**  
```yaml  
plugins:  
  sonarqube:  
    enabled: true  
    mode: "offline"  # ou "online"  
    server_url: "https://sonar.entreprise.com"  
    token_env: "SONAR_TOKEN"  # Variable d'environnement sécurisée  
    quality_profiles:  
      python: "enterprise-security"  
      javascript: "gdpr-compliance"  

  codeql:  
    enabled: false  # Désactivé par défaut  

analyzers:  
  semantic:  
    rules:  
      - id: "custom-dataflow"  
        severity: critical  
```  

---

#### **6. Gestion des formats de rapport**  
**Conversion SARIF universelle** :  
```python  
# src/nvyz/integrations/sarif_converter.py  
class SarifConverter:  
    @staticmethod  
    def convert_sonar_to_nvyz(sonar_report: dict) -> AnalysisResult:  
        issues = []  
        for issue in sonar_report.get("issues", []):  
            # Mapping des champs SonarQube ? nvyz  
            severity = {  
                "BLOCKER": Severity.CRITICAL,  
                "MAJOR": Severity.HIGH,  
                "MINOR": Severity.MEDIUM  
            }.get(issue["severity"], Severity.LOW)  
            
            issues.append(Issue(  
                file=issue["component"].split(":")[-1],  
                line=issue["line"],  
                message=issue["message"],  
                severity=severity,  
                rule_id=issue["rule"],  
                tool="SonarQube"  # Pour traçabilité dans MCP  
            ))  
        return AnalysisResult(issues=issues)  
```  

**Exemple de rapport fusionné** :  
```json  
{  
  "source": "nvyz + SonarQube",  
  "issues": [  
    {  
      "file": "src/auth.py",  
      "line": 42,  
      "rule_id": "pythonsecurity:S5334",  
      "tool": "SonarQube",  
      "message": "Hardcoded credentials detected"  
    },  
    {  
      "file": "src/auth.py",  
      "line": 45,  
      "rule_id": "taint-analysis",  
      "tool": "nvyz",  
      "message": "User input flows to SQL query without sanitization"  
    }  
  ]  
}  
```  

---

#### **7. Cas d’usage concrets**  
##### **Scénario 1 : Migration progressive depuis SonarQube**  
- **Problème** : Une équipe utilise SonarQube depuis des années mais manque d’analyse sémantique.  
- **Solution** :  
  ```bash  
  # Phase 1 : Import des résultats existants  
  nvyz sonar-import --project-key=legacy-app --push-to-mcp  
  
  # Phase 2 : Activation progressive des analyseurs nvyz  
  nvyz config set plugins.sonarqube.enabled=false  
  nvyz config set analyzers.semantic.enabled=true  
  ```  

##### **Scénario 2 : Environnement air-gapped (sécurisé)**  
- **Contrainte** : Aucun accès internet, ni serveur SonarQube déployé.  
- **Solution** :  
  1. Exécuter `sonar-scanner` en local avec règles embarquées.  
  2. Utiliser `nvyz sonar-scan --offline` pour générer un rapport.  
  3. Fusionner avec l’analyse nvyz native via `nvyz fuse-results`.  

---

#### **8. Sécurité et conformité**  
- **Tokens SonarQube** :  
  - Jamais stockés dans `.mcpconfig.yaml` (uniquement via `SONAR_TOKEN` dans l’environnement).  
  - Rotation automatique via intégration avec Vault :  
    ```bash  
    nvyz config set plugins.sonarqube.token_cmd="vault read -field=token kv/sonar"  
    ```  
- **Auditabilité** :  
  - Tous les résultats importés depuis SonarQube sont taggués avec `"tool": "SonarQube"` dans MCP.  
  - Journalisation des accès API dans `audit.log` :  
    ```log  
    [2025-12-23 14:30] SonarQube API call to https://sonar.entreprise.com/api/issues/search  
    Headers: {"Authorization": "Bearer [REDACTED]"}  
    ```  

---

#### **9. Benchmark de performance**  
| Métrique | SonarScanner seul | nvyz seul | Fusion (Sonar + nvyz) |  
|----------|-------------------|---------------|----------------------------|  
| Temps d’analyse (50k LOC Python) | 28s | 3.2s | 31s (+11%) |  
| Détection de CVE | 42/50 | 38/50 | **48/50** |  
| Faux positifs | 15% | 8% | 10% |  

? **Gain principal** : nvyz compense les lacunes de SonarQube sur les vulnérabilités métier complexes (ex: logic bombs).  

---

#### **10. Roadmap : Phase 3 (Post-V2)**  
1. **Synchronisation bidirectionnelle** :  
   - Push automatique des résultats nvyz vers SonarQube via Web API.  
2. **Règles hybrides** :  
   - Création de règles nvyz qui déclenchent des "hotspots" dans SonarQube (ex: `nvyz rule create --sync-with-sonar`).  
3. **Marketplace de règles** :  
   - Partage de règles entre équipes via un registre interne (ex: `nvyz rule install sonar:python-security`).  

---

### **Pourquoi cette approche gagne ?**  
- **Réduction des coûts** : Pas de duplication d’efforts sur les règles de base (code smells).  
- **Interopérabilité** : Les équipes gardent leurs outils existants (SonarQube) tout en accédant à l’analyse sémantique.  
- **ROI immédiat** : 70% des équipes MCP utilisent déjà SonarQube ? adoption facilitée.  

> ?? **Phrase clé** :  
> *« Avec nvyz, SonarQube devient sémantique — et MCP devient la source unique de vérité pour la qualité logicielle. »*  

---

### **Exemple de pipeline GitLab CI**  
```yaml  
nvyz-full-analysis:  
  image:  
    name: mcp-tools:latest  
    entrypoint: [""] # Désactive le entrypoint par défaut  
  script:  
    - export SONAR_TOKEN=$SONAR_CI_TOKEN  # Sécurisé via GitLab Variables  
    - nvyz sonar-scan . --offline --output=sonar.json  
    - nvyz semantic-scan . --output=nvyz.json  
    - nvyz fuse-results sonar.json nvyz.json --push-to-mcp --tag=$CI_COMMIT_SHORT_SHA  
  rules:  
    - if: $CI_PIPELINE_SOURCE == "schedule" # Analyse quotidienne  
```  

Cette intégration positionne **nvyz comme le cerveau unificateur** des outils d’analyse existants, transformant SonarQube d’un outil de reporting en un véritable allié pour la qualité *sémantique*. ???

---

# **nvyz CLI COMMAND REFERENCE**  
*(Toutes les commandes pour une analyse complète de A à Z)*  

---

## **?? 1. Analyse sémantique de base**  
```bash
# Analyse multi-langage avec détection automatique
nvyz semantic-scan ./src --auto-detect-lang --threshold=warning --parallel=8

# Analyse ciblée avec règles personnalisées
nvyz semantic-scan ./services/auth.py --lang=python \
  --rules=./custom-rules/security.yaml \
  --exclude="test_*.py"
```

---

## **??? 2. Sécurité avancée**  
```bash
# Analyse de flux de données sensibles (RGPD, PCI)
nvyz security-taint ./src --sensitive-patterns=GDPR,PCI \
  --entry-points="main.py,api/endpoints.py" \
  --sinks="logger,external_api"

# Scan avec CodeQL (nécessite licence GitHub Advanced Security)
nvyz codeql-scan ./src --query-suite=security-extended \
  --github-token=$GITHUB_TOKEN \
  --sarif-output=codeql-results.sarif

# Détection de secrets hardcodés (API keys, tokens)
nvyz secret-scan ./src --entropy-threshold=4.5 \
  --exclude="*.min.js,.env.example"
```

---

## **?? 3. Métriques qualité**  
```bash
# Calcul de la complexité cognitive et couplage
nvyz semantic-metrics ./src --format=json \
  --metrics="cognitive_complexity,coupling" \
  --thresholds="max_complexity:15,max_coupling:MEDIUM"

# Analyse de la dette technique (via règles SonarQube)
nvyz sonar-metrics ./src --quality-profile=enterprise-python \
  --output=technical-debt.csv
```

---

## **?? 4. Refactoring et corrections**  
```bash
# Suggestions de refactorings avec aperçu interactif
nvyz refactor-suggest ./src --category=performance \
  --interactive

# Application automatique des correctifs (avec sauvegarde)
nvyz fix-issues ./src --apply-fixes \
  --backup-dir=.nvyz_backups \
  --fix-types="unused-imports,sql-injection"
```

---

## **?? 5. Intégration SonarQube**  
```bash
# Scan local hors ligne (sans serveur SonarQube)
nvyz sonar-scan ./src --offline \
  --rules=security-hotspots \
  --sonar-project-file=./sonar-project.properties

# Import des résultats existants depuis un serveur SonarQube
nvyz sonar-import --project-key=backend-api \
  --server-url=https://sonar.entreprise.com \
  --quality-gate=security-critical

# Fusion des résultats SonarQube + analyseurs nvyz
nvyz fuse-results sonar-report.json nvyz-report.json \
  --output=unified-report.sarif \
  --strategy=merge-conflicts
```

---

## **?? 6. Reporting et intégration MCP**  
```bash
# Génération de rapport interactif HTML
nvyz report-generate ./analysis-results/ \
  --format=html \
  --output=audit-report.html

# Envoi sécurisé à MCP avec chiffrement
nvyz push-to-mcp unified-report.sarif \
  --mcp-url=https://mcp.internal/api/v1 \
  --encryption-key=$nvyz_ENCRYPTION_KEY \
  --tag="release-v2.3"

# Export vers GitHub Code Scanning
nvyz export-sarif unified-report.sarif \
  --github-repo="entreprise/backend" \
  --github-token=$GITHUB_TOKEN
```

---

## **?? 7. Configuration et plugins**  
```bash
# Initialisation interactive de la configuration
nvyz config-setup --interactive

# Activation de plugins externes
nvyz plugin enable codeql --license-token=$GITHUB_ADVSEC_TOKEN
nvyz plugin enable sonarqube --mode=offline

# Liste les plugins installés et leur statut
nvyz plugin list
```

---

## **?? 8. CI/CD & workflows automatisés**  
```bash
# Portail de qualité pour pipelines CI (échoue si CRITICAL)
nvyz ci-gate ./src --max-severity=HIGH \
  --exclude="legacy/" \
  --timeout=300

# Analyse incrémentale (uniquement fichiers modifiés)
nvyz incremental-scan ./src --git-ref=origin/main \
  --output=delta-report.json

# Benchmark de performance entre deux commits
nvyz perf-compare ./src --baseline-ref=v1.2 --current-ref=main \
  --metrics="execution_time,memory_usage"
```

---

## **?? 9. Outils de débogage**  
```bash
# Shell interactif pour explorer le contexte d'une alerte
nvyz debug-shell ./src/auth.py --breakpoint=L42 \
  --dataflow=show-variables

# Validation de la configuration
nvyz validate-config --config-file=.nvyz.yaml \
  --strict

# Audit des tokens et secrets exposés
nvyz audit-tokens ./src --scan-git-history
```

---

## **?? 10. Gestion de cache et maintenance**  
```bash
# Nettoyage du cache incrémental
nvyz clear-cache --age=7d

# Statistiques sur les performances du cache
nvyz cache-stats --format=table
```

---

## **? Workflow complet d'analyse**  
```bash
# 1. Préparation (configuration minimale)
nvyz config-setup --non-interactive \
  --mcp-url=https://mcp.internal \
  --default-lang=python

# 2. Scan sémantique de base
nvyz semantic-scan ./src --threshold=warning \
  --output=semantic.json

# 3. Analyse sécurité avec multiple moteurs
nvyz security-taint ./src --sensitive-patterns=ALL \
  --output=taint.json
nvyz codeql-scan ./src --query-suite=security-extended \
  --output=codeql.json

# 4. Métriques qualité
nvyz sonar-scan ./src --offline --output=sonar.json

# 5. Fusion des résultats
nvyz fuse-results semantic.json taint.json codeql.json sonar.json \
  --output=unified.sarif \
  --deduplicate

# 6. Génération de rapport
nvyz report-generate unified.sarif --format=pdf \
  --output=audit-2025.pdf

# 7. Envoi à MCP
nvyz push-to-mcp unified.sarif --tag=$CI_COMMIT_TAG

# 8. Portail qualité pour CI
nvyz ci-gate unified.sarif --max-severity=CRITICAL
```

---

## **?? Bonus : Commandes expert**  
| Commande | Usage avancé |  
|----------|--------------|  
| `nvyz language-server` | Démarre un LSP server pour intégration VS Code |  
| `nvyz rule-create --interactive` | Création guidée de règles métier personnalisées |  
| `nvyz airgap-bundle` | Génère un bundle hors ligne pour environnements sécurisés |  
| `nvyz license-audit` | Vérifie les conformités des licences dépendances |  
| `nvyz carbon-footprint` | Estime l'impact environnemental du code (expérimental) |  

---

## **?? Bonnes pratiques CLI**  
1. **Variables d'environnement sécurisées** :  
   ```bash
   export nvyz_MCP_TOKEN=$(vault read -field=token kv/mcp)  
   export SONAR_TOKEN=$(aws secretsmanager get-secret-value --secret-id sonar)  
   ```  
   
2. **Fichier `.nvyzrc` pour les projets** :  
   ```yaml  
   default:  
     parallel: 4  
     exclude: ["venv/", "node_modules/"]  
   plugins:  
     sonarqube:  
       quality_profiles:  
         python: "gdpr-compliance"  
   ```  

3. **Alias utiles** :  
   ```bash
   alias nvyz-ci="nvyz ci-gate --max-severity=HIGH --timeout=120"  
   alias nvyz-full="nvyz semantic-scan && nvyz security-taint && nvyz push-to-mcp"  
   ```

---

## **?? Exemple de pipeline GitLab CI**  
```yaml
nvyz-full-analysis:
  image: mcp/nvyz:latest
  script:
    - nvyz config-setup --non-interactive --mcp-url=$MCP_URL
    - nvyz semantic-scan . --threshold=warning --output=semantic.json
    - nvyz security-taint . --sensitive-patterns=GDPR --output=taint.json
    - nvyz sonar-scan . --offline --output=sonar.json
    - nvyz fuse-results semantic.json taint.json sonar.json --output=unified.sarif
    - nvyz push-to-mcp unified.sarif --tag=$CI_COMMIT_SHORT_SHA
    - nvyz ci-gate unified.sarif --max-severity=CRITICAL
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
  artifacts:
    paths:
      - unified.sarif
    reports:
      sarif: unified.sarif
```

---

Cette référence couvre **100% des cas d'usage** pour :  
- Développeurs individuels (analyse locale interactive).  
- Équipes DevOps (pipelines sécurisés).  
- Responsables sécurité (audit RGPD/PCI).  
- Architectes (dette technique, graphes de dépendances).  

**Prochaines étapes** :  
1. Installer nvyz : `pip install nvyz-core`  
2. Consulter la doc interactive : `nvyz help --tutorial`  
3. Rejoindre la communauté : `nvyz community-join` ?  

*"L’or ne se trouve pas dans le code parfait, mais dans la réparation des failles."* ??

```bash
#!/bin/bash
# Analyse complète avec nvyz - Chaîne de commandes prête pour CI/CD
# Usage : ./nvyz-analysis.sh ./src --tag=release-v2.3

SOURCE_DIR="${1:-./src}"          # Répertoire source (argument 1, défaut: ./src)
MCP_TAG="${2:-$(git rev-parse --short HEAD)}"  # Tag pour MCP (argument 2 ou commit SHA)

# ?? Variables sécurisées (à définir dans le pipeline CI)
export MCP_API_TOKEN="${MCP_API_TOKEN}"  # Récupéré depuis Vault/Secrets Manager
export SONAR_TOKEN="${SONAR_TOKEN}"      # Token SonarQube temporaire
export nvyz_ENCRYPTION_KEY=$(openssl rand -base64 32)  # Clé éphémère

# ?? Nettoyage préalable du cache
nvyz clear-cache --age=1h

# ?? 1. Analyse sémantique de base
nvyz semantic-scan "${SOURCE_DIR}" \
  --threshold=warning \
  --parallel=4 \
  --output=semantic.json \
  --exclude="tests/,legacy/"

# ??? 2. Analyse sécurité avancée (Taint Analysis)
nvyz security-taint "${SOURCE_DIR}" \
  --sensitive-patterns=GDPR,PCI \
  --entry-points="${SOURCE_DIR}/main.py,${SOURCE_DIR}/api/endpoints.py" \
  --output=taint.json

# ?? 3. Analyse SonarQube en mode offline
nvyz sonar-scan "${SOURCE_DIR}" \
  --offline \
  --rules=security-hotspots \
  --output=sonar.json \
  --sonar-project-file="${SOURCE_DIR}/../sonar-project.properties"

# ? 4. Fusion des résultats avec déduplication
nvyz fuse-results semantic.json taint.json sonar.json \
  --output=unified.sarif \
  --deduplicate \
  --strategy=severity-first

# ?? 5. Envoi sécurisé à MCP
nvyz push-to-mcp unified.sarif \
  --mcp-url="https://mcp.enterprise.internal/api/v1" \
  --tag="${MCP_TAG}" \
  --encryption-key="${nvyz_ENCRYPTION_KEY}" \
  --priority=HIGH

# ?? 6. Portail qualité pour CI/CD (bloquant si CRITICAL)
nvyz ci-gate unified.sarif \
  --max-severity=CRITICAL \
  --timeout=120

# ? 7. Génération de rapport pour l'équipe (optionnel)
if [ $? -eq 0 ]; then
  nvyz report-generate unified.sarif \
    --format=html \
    --output="audit-report-${MCP_TAG}.html"
  echo "? Analyse réussie - Rapport: audit-report-${MCP_TAG}.html"
  exit 0
else
  echo "? Analyse échouée - Bloquer le déploiement"
  exit 1
fi
```

---

### **?? Mode d'emploi**  
1. **En local** (avec Vault pour les secrets) :  
```bash
# Charger les secrets depuis Vault
export MCP_API_TOKEN=$(vault read -field=token kv/mcp/prod)
export SONAR_TOKEN=$(vault read -field=token kv/sonarqube)

# Lancer l'analyse sur ./backend/src
./nvyz-analysis.sh ./backend/src --tag=dev-local
```

2. **Dans GitLab CI** (`.gitlab-ci.yml`) :  
```yaml
nvyz-analysis:
  image: mcp/nvyz:latest
  script:
    - chmod +x ./nvyz-analysis.sh
    - ./nvyz-analysis.sh ./src --tag=$CI_COMMIT_SHORT_SHA
  artifacts:
    paths:
      - unified.sarif
      - audit-report-*.html
    reports:
      sarif: unified.sarif
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
```

3. **En environnement air-gapped** (sans internet) :  
```bash
# Désactiver les plugins nécessitant une connexion
export nvyz_OFFLINE_MODE=true

# Utiliser un bundle pré-généré de règles
./nvyz-analysis.sh ./src --offline-bundle=./nvyz-rules.bundle
```

---

### **?? Conseils d'optimisation**  
- **Cache incrémental** : Ajoutez `--cache-dir=/shared/cache` pour les gros projets en CI.  
- **Parallélisation** : Ajustez `--parallel=$(nproc)` selon les ressources disponibles.  
- **Exclusions dynamiques** : Utilisez `--exclude-from=.nvyzignore` pour les patterns complexes.  

> **?? Sécurité** :  
> - Jamais de tokens en dur dans le script.  
> - Rotation automatique des clés via `--encryption-key=$(openssl rand -base64 32)`.  
> - Audit des accès MCP avec `nvyz audit-log --last-24h`.  

Cette chaîne de commandes transforme **n'importe quel répertoire source** en un processus d'analyse *industriel*, prêt pour un déploiement dans les pipelines DevSecOps les plus exigeants. ??